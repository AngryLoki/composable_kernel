#ifndef CK_FLOAT_TYPE_AMD_HPP
#define CK_FLOAT_TYPE_AMD_HPP

namespace ck {

// For some reason, HIP compiler need this definition to generate optimal ISA
// fp32
typedef float float2_t __attribute__((ext_vector_type(2)));
typedef float float4_t __attribute__((ext_vector_type(4)));
typedef float float8_t __attribute__((ext_vector_type(8)));
typedef float float16_t __attribute__((ext_vector_type(16)));
typedef float float32_t __attribute__((ext_vector_type(32)));

// fp16
typedef _Float16 half_t;
typedef _Float16 half2_t __attribute__((ext_vector_type(2)));
typedef _Float16 half4_t __attribute__((ext_vector_type(4)));
typedef _Float16 half8_t __attribute__((ext_vector_type(8)));

// bfp16
typedef ushort ushort2_t __attribute__((ext_vector_type(2)));
typedef ushort ushort4_t __attribute__((ext_vector_type(4)));
typedef ushort ushort8_t __attribute__((ext_vector_type(8)));

struct c_vec32_4_t
{
    union VecType
    {
        struct
        {
            float32_t x;
            float32_t y;
            float32_t z;
            float32_t w;
        } s;
        float n[128];
    };

    __host__ __device__ static VecType CreateVecZero()
    {
        VecType c;
        c.s.x = 0;
        c.s.y = 0;
        c.s.z = 0;
        c.s.w = 0;
        return c;
    }
};

struct c_vec32_2_t
{
    union VecType
    {
        struct
        {
            float32_t x;
            float32_t y;
        } s;
        float n[64];
    } l;

    __host__ __device__ static VecType CreateVecZero()
    {
        VecType c;
        c.s.x = 0;
        c.s.y = 0;
        return c;
    }
};

struct c_vec32_2_2_t
{
    union VecType
    {
        struct
        {
            c_vec32_2_t x;
            c_vec32_2_t y;
        } s;
        float n[128];
    };

    __host__ __device__ static VecType CreateVecZero()
    {
        VecType c;
        c.s.x.l.s.x = 0;
        c.s.x.l.s.y = 0;
        c.s.y.l.s.x = 0;
        c.s.y.l.s.y = 0;
        return c;
    }
};

struct c_vec32_1_t
{
    union VecType
    {
        struct
        {
            float32_t x;
        } s;
        float n[32];
    };

    __host__ __device__ static VecType CreateVecZero()
    {
        VecType c;
        c.s.x = 0;
        return c;
    }
};

struct c_vec16_1_t
{
    union VecType
    {
        struct
        {
            float16_t x;
        } s;
        float n[16];
    };

    __host__ __device__ static VecType CreateVecZero()
    {
        VecType c;
        c.s.x = 0;
        return c;
    }
};

struct c_vec4_2_t
{
    union VecType
    {
        struct
        {
            float4_t x;
            float4_t y;
        } s;
        float n[8];
    };

    __host__ __device__ static VecType CreateVecZero()
    {
        VecType c;
        c.s.x = 0;
        c.s.y = 0;
        return c;
    }
};

struct c_vec4_1_t
{
    union VecType
    {
        struct
        {
            float4_t x;
        } s;
        float n[4];
    };

    __host__ __device__ static VecType CreateVecZero()
    {
        VecType c;
        c.s.x = 0;
        return c;
    }
};

template <typename T, index_t N>
struct vector_type;

template <typename T>
struct vector_type<T, 1>
{
    using MemoryType = T;

    T data_;

    __host__ __device__ constexpr vector_type() : data_{T{0}} {}

    __host__ __device__ static constexpr index_t Size() { return 1; }

    __host__ __device__ constexpr const auto& Vector() const { return data_; }

    __host__ __device__ constexpr auto& Vector() { return data_; }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<1>, Number<I>) const
    {
        static_assert(I == 0, "wrong!");

        return data_;
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<1>, Number<I>)
    {
        static_assert(I == 0, "wrong!");

        return data_;
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& operator[](Number<I>) const
    {
        static_assert(I == 0, "wrong!");

        return data_;
    }

    template <index_t I>
    __host__ __device__ constexpr auto& operator()(Number<I>)
    {
        static_assert(I == 0, "wrong!");

        return data_;
    }
};

template <typename T>
struct vector_type<T, 2>
{
    using d1_t = T;
    typedef T d2_t __attribute__((ext_vector_type(2)));

    using MemoryType = d2_t;

    union
    {
        d2_t d2_;
        StaticallyIndexedArray<d1_t, 2> d1x2_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{d2_t{0}} {}

    __host__ __device__ static constexpr index_t Size() { return 2; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d2_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d2_; }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<1>, Number<I> i) const
    {
        static_assert(I >= 0 && I < 2, "wrong!");

        return data_.d1x2_[i];
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<2>, Number<I>) const
    {
        static_assert(I == 0, "wrong!");

        return data_.d2_;
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<1>, Number<I> i)
    {
        static_assert(I >= 0 && I < 2, "wrong!");

        return data_.d1x2_(i);
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<2>, Number<I>)
    {
        static_assert(I == 0, "wrong!");

        return data_.d2_;
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& operator[](Number<I>) const
    {
        static_assert(I >= 0 && I < 2, "wrong!");

        return data_.d1x2_[Number<I>{}];
    }

    template <index_t I>
    __host__ __device__ constexpr auto& operator()(Number<I>)
    {
        static_assert(I >= 0 && I < 2, "wrong!");

        return data_.d1x2_(Number<I>{});
    }
};

template <typename T>
struct vector_type<T, 4>
{
    using d1_t = T;
    typedef T d2_t __attribute__((ext_vector_type(2)));
    typedef T d4_t __attribute__((ext_vector_type(4)));

    using MemoryType = d4_t;

    union
    {
        d4_t d4_;
        StaticallyIndexedArray<d1_t, 4> d1x4_;
        StaticallyIndexedArray<d2_t, 2> d2x2_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{d4_t{0}} {}

    __host__ __device__ static constexpr index_t Size() { return 4; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d4_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d4_; }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<1>, Number<I> i) const
    {
        static_assert(I >= 0 && I < 4, "wrong!");

        return data_.d1x4_[i];
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<2>, Number<I> i) const
    {
        static_assert(I >= 0 && I < 2, "wrong!");

        return data_.d2x2_[i];
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<4>, Number<I>) const
    {
        static_assert(I == 0, "wrong!");

        return data_.d4_;
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<1>, Number<I> i)
    {
        static_assert(I >= 0 && I < 4, "wrong!");

        return data_.d1x4_(i);
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<2>, Number<I> i)
    {
        static_assert(I >= 0 && I < 3, "wrong!");

        return data_.d2x2_(i);
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<4>, Number<I>)
    {
        static_assert(I == 0, "wrong!");

        return data_.d4_;
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& operator[](Number<I>) const
    {
        static_assert(I >= 0 && I < 4, "wrong!");

        return data_.d1x4_[Number<I>{}];
    }

    template <index_t I>
    __host__ __device__ constexpr auto& operator()(Number<I>)
    {
        static_assert(I >= 0 && I < 4, "wrong!");

        return data_.d1x4_(Number<I>{});
    }
};

template <typename T>
struct vector_type<T, 8>
{
    using d1_t = T;
    typedef T d2_t __attribute__((ext_vector_type(2)));
    typedef T d4_t __attribute__((ext_vector_type(4)));
    typedef T d8_t __attribute__((ext_vector_type(8)));

    using MemoryType = d8_t;

    union
    {
        d8_t d8_;
        StaticallyIndexedArray<d1_t, 8> d1x8_;
        StaticallyIndexedArray<d2_t, 4> d2x4_;
        StaticallyIndexedArray<d4_t, 2> d4x2_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{d8_t{0}} {}

    __host__ __device__ static constexpr index_t Size() { return 8; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d8_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d8_; }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<1>, Number<I> i) const
    {
        static_assert(I >= 0 && I < 8, "wrong!");

        return data_.d1x8_[i];
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<2>, Number<I> i) const
    {
        static_assert(I >= 0 && I < 4, "wrong!");

        return data_.d2x4_[i];
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<4>, Number<I> i) const
    {
        static_assert(I >= 0 && I < 2, "wrong!");

        return data_.d4x2_[i];
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& Get(Number<8>, Number<I>) const
    {
        static_assert(I == 0, "wrong!");

        return data_.d8_;
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<1>, Number<I> i)
    {
        static_assert(I >= 0 && I < 8, "wrong!");

        return data_.d1x8_(i);
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<2>, Number<I> i)
    {
        static_assert(I >= 0 && I < 4, "wrong!");

        return data_.d2x4_(i);
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<4>, Number<I> i)
    {
        static_assert(I >= 0 && I < 2, "wrong!");

        return data_.d4x2_(i);
    }

    template <index_t I>
    __host__ __device__ constexpr auto& Set(Number<8>, Number<I> i)
    {
        static_assert(I == 0, "wrong!");

        return data_.d8_;
    }

    template <index_t I>
    __host__ __device__ constexpr const auto& operator[](Number<I>) const
    {
        static_assert(I >= 0 && I < 8, "wrong!");

        return data_.d1x8_[Number<I>{}];
    }

    template <index_t I>
    __host__ __device__ constexpr auto& operator()(Number<I>)
    {
        static_assert(I >= 0 && I < 8, "wrong!");

        return data_.d1x8_(Number<I>{});
    }
};

// data type conversion
template <typename T>
struct type_convert
{
    template <typename X>
    __device__ T operator()(X x) const
    {
        return static_cast<T>(x);
    }
};

template <>
template <>
__device__ float type_convert<float>::operator()<ushort>(ushort x) const
{
    return bfloat16_to_float(x);
}

template <>
template <>
__device__ ushort type_convert<ushort>::operator()<float>(float x) const
{
    return float_to_bfloat16(x);
}

template <typename T>
struct inner_product_with_conversion
{
    static constexpr auto convert = type_convert<T>();

    __device__ T operator()(float4_t a, float4_t b) const
    {
        const float* p_a_float = reinterpret_cast<const float*>(&a);
        const float* p_b_float = reinterpret_cast<const float*>(&b);

        T acc = 0;
        for(index_t v = 0; v < 4; ++v)
        {
            acc += convert(p_a_float[v]) * convert(p_b_float[v]);
        }

        return acc;
    }

    __device__ T operator()(float2_t a, float2_t b) const
    {
        const float* p_a_float = reinterpret_cast<const float*>(&a);
        const float* p_b_float = reinterpret_cast<const float*>(&b);

        T acc = 0;
        for(index_t v = 0; v < 2; ++v)
        {
            acc += convert(p_a_float[v]) * convert(p_b_float[v]);
        }

        return acc;
    }

    __device__ T operator()(float a, float b) const { return convert(a) * convert(b); }

    __device__ T operator()(half2_t a, half2_t b) const
    {
        const half_t* p_a_half = reinterpret_cast<const half_t*>(&a);
        const half_t* p_b_half = reinterpret_cast<const half_t*>(&b);

        T acc = 0;
        for(index_t v = 0; v < 2; ++v)
        {
            acc += convert(p_a_half[v]) * convert(p_b_half[v]);
        }

        return acc;
    }

    __device__ T operator()(half4_t a, half4_t b) const
    {
        const half_t* p_a_half = reinterpret_cast<const half_t*>(&a);
        const half_t* p_b_half = reinterpret_cast<const half_t*>(&b);

        T acc = 0;
        for(index_t v = 0; v < 4; ++v)
        {
            acc += convert(p_a_half[v]) * convert(p_b_half[v]);
        }
        return acc;
    }

    __device__ T operator()(half8_t a, half8_t b) const
    {
        const half_t* p_a_half = reinterpret_cast<const half_t*>(&a);
        const half_t* p_b_half = reinterpret_cast<const half_t*>(&b);

        T acc = 0;
        for(index_t v = 0; v < 8; ++v)
        {
            acc += convert(p_a_half[v]) * convert(p_b_half[v]);
        }
        return acc;
    }

    __device__ T operator()(ushort2_t a, ushort2_t b) const
    {
        const ushort* p_a_bfloat16 = reinterpret_cast<const ushort*>(&a);
        const ushort* p_b_bfloat16 = reinterpret_cast<const ushort*>(&b);

        T acc = 0;
        for(index_t v = 0; v < 2; ++v)
        {
            acc += convert(p_a_bfloat16[v]) * convert(p_b_bfloat16[v]);
        }

        return acc;
    }

    __device__ T operator()(ushort4_t a, ushort4_t b) const
    {
        const ushort* p_a_bfloat16 = reinterpret_cast<const ushort*>(&a);
        const ushort* p_b_bfloat16 = reinterpret_cast<const ushort*>(&b);

        T acc = 0;
        for(index_t v = 0; v < 4; ++v)
        {
            acc += convert(p_a_bfloat16[v]) * convert(p_b_bfloat16[v]);
        }
        return acc;
    }

    __device__ T operator()(ushort8_t a, ushort8_t b) const
    {
        const ushort* p_a_bfloat16 = reinterpret_cast<const ushort*>(&a);
        const ushort* p_b_bfloat16 = reinterpret_cast<const ushort*>(&b);

        T acc = 0;
        for(index_t v = 0; v < 8; ++v)
        {
            acc += convert(p_a_bfloat16[v]) * convert(p_b_bfloat16[v]);
        }
        return acc;
    }
};

} // namespace ck
#endif
